% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/confint.R
\name{confint.RSA}
\alias{confint.RSA}
\alias{confint}
\title{Computes confidence intervals for RSA parameters, standard or bootstrapped}
\usage{
\method{confint}{RSA}(object, parm, level = 0.95, ..., model = "full",
  digits = 3, method = "standard", R = 5000)
}
\arguments{
\item{object}{An RSA object}

\item{parm}{Not used.}

\item{level}{The confidence level required.}

\item{...}{Additional parameters passed to the bootstrapLavaan function, e.g., \code{parallel="multicore", ncpus=2}.}

\item{model}{A string specifying the model; defaults to "full"}

\item{digits}{Number of digits the output is rounded to; if NA, digits are unconstrained}

\item{method}{"standard" returns the CI for the lavaan object as it was computed. "boot" computes new percentile bootstrapped CIs.}

\item{R}{If \code{method = "boot"}, R specifies the number of bootstrap samples}
}
\description{
Computes confidence intervals for RSA parameters, standard or bootstrapped (using a percentile bootstrap)
}
\details{
There are two ways of getting bootstrapped CIs and p-values in the RSA package If you use the option \code{se="boot"} in the \code{\link{RSA}} function, \code{lavaan} provides CIs and p-values based on the bootstrapped standard error (\emph{not} percentile bootstraps). If you use \code{confint(..., method="boot")}, in contrast, you get CIs and p-values based on percentile bootstrap.
}
\examples{

\dontrun{
set.seed(0xBEEF)
n <- 300
err <- 2
x <- rnorm(n, 0, 5)
y <- rnorm(n, 0, 5)
df <- data.frame(x, y)
df <- within(df, {
	diff <- x-y
	absdiff <- abs(x-y)
	SD <- (x-y)^2
	z.sq <- SD + rnorm(n, 0, err)
})

r1 <- RSA(z.sq~x*y, df, models="SSQD")
(c1 <- confint(r1, model="SSQD"))

# Dummy example with 10 bootstrap replications - better use >= 5000!
(c2 <- confint(r1, model="SSQD", method="boot", R=10))
# multicore version
confint(r1, model="SSQD", R=5000, parallel="multicore", ncpus=2)
}
}
\seealso{
\code{\link{RSA}}
}
